import { Intro } from '../components/intro';

# Utility-first CSS, a redundant abstraction.

I always felt that the so called Utility CSS frameworks like
[Tailwind](https://tailwindcss.com/) and [Tachyons](https://tachyons.io/) were novel ideas. At first glance it made a lot of sense to me, but in reality I ended up never using them. Regardless, they pioneered the concept of [Atomic CSS](https://css-tricks.com/lets-define-exactly-atomic-css/) which I believe still carries merit, if done right.

This is not about the usual back and forth
[arguing](https://news.ycombinator.com/item?id=21553496) on separation of concerns.
I've already bought into the React philosophy of componentization, so I'm fine with
the idea of mixing CSS, JavaScript and markup. This is *not* to imply that I'm an advocate of inlining CSS or JavaScript using the `style` or event handlers (eg. `onclick`) directly on HTML elements, that's a different story.


## Why Atomic CSS appeals to me

- I don't have to think about CSS naming conventions or file structure (and enforcing them)
- No unused CSS lying around, no cleanup required.
- No globals or unintended side-effects.
- Easy to programatically figure out what styles are required to render a specific page and therfor making previously near impossible tasks such as "automation of inlining critical CSS to render" fairly trivial. No more x KB of render blocking CSS!

The above also applies to most CSS-in-JS frameworks but there is one unique benefit to Atomic CSS: A style property is only declared once, and can be-reused across components. Resulting in non-growing stylesheets as explained by [Ryan Tsao](https://ryantsao.com/blog/virtual-css-with-styletron):

> Thereâ€™s ultimately a finite number of different font sizes, widths, and colors in any given application. And in practice, for purposes of design consistency, the options are often intentionally restricted to a small set of shared values which are then repeated many times throughout the application.


## What doesn't appeal to me

With all the the benefits previously mentioned, why do I disapprove of Utility CSS Frameworks? This is only about my own shortcoming. You see, I want to build scalable, accessible and performant web UI, but I'm **lazy**.


### Learning a new abstraction

In my experience class names in Utility CSS frameworks like Tailwind are semantic, brief and generally easy to understand. With that being said, I still find myself having to look up what they translate to. To be fair, the Tailwind docs are very well written and comprehensible but I feel I'm forced to re-learn something I already know.

```html
<!-- Example from Tailwind docs -->
<form>
  <input class="bg-gray-200 hover:bg-white hover:border-gray-300 focus:outline-none focus:bg-white focus:shadow-outline focus:border-gray-300 ...">
  <button class="bg-teal-500 hover:bg-teal-600 focus:outline-none focus:shadow-outline ...">
    Sign Up
  </button>
</form>
```

### Optimizing for production

Given that Utility-CSS frameworks have to re-implement every single style the raw unoptimized CSS file will be [very big](https://tailwindcss.com/docs/controlling-file-size/), and not so great for performance.

To mitigate this, frameworks like Tailwind provide a build step that will allow me to figure out exactly
what parts of the CSS utility abstraction I'm using, and only cherry pick
those classes to create a production optimized build. This unfortunately is a configuration that will have to be actively maintained.

## What if there was a way to to just write regular CSS and automate the whole process?
